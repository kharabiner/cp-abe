# CP-ABE 실험 결과 상세 분석 (2025)

본 문서는 2025년 실시한 CP-ABE와 기존 방식의 성능 비교 실험 결과에 대한 상세 분석을 제공합니다.

## 1. 주요 발견

1. **효율성 교차점**: CP-ABE는 약 588대 기기부터 기존 방식보다 더 효율적입니다. 이는 당초 예상했던 수천 대보다 훨씬 낮은 수치입니다.

2. **시간 기반 접근 제한**: CP-ABE의 시간 기반 속성을 활용한 접근 제한이 기기 수와 관계없이 일정한 성능(약 0.00004초)을 제공하며, 이는 모든 기기에 키를 재발급해야 하는 기존 방식보다 훨씬 효율적입니다.

3. **부분 키 갱신**: 속성이 14개인 경우, 단일 속성 갱신이 전체 키 재발급보다 11배 이상 효율적이며, 이러한 효율성은 속성 수가 증가할수록 더 커집니다.

4. **대역폭 절약**: CP-ABE는 100대 이상의 기기 환경에서 99.9% 이상의 네트워크 대역폭을 절약할 수 있습니다.

## 2. 실험 환경 세부 정보

실험은 Docker 컨테이너 내에서 진행되었으며, 다음과 같은 환경 설정을 사용했습니다:

- **Python 버전**: 3.9
- **라이브러리**: charm-crypto, cryptography, numpy, matplotlib
- **메모리 제한**: 1GB
- **실험 대상 기기 수**: 1, 10, 50, 100, 500, 1000, 2000, 3000, 4000, 5000대
- **실험 대상 속성 수**: 2, 4, 6, 8, 10, 12, 14개

## 3. 측정값 상세 분석

### 3.1 암호화 시간 비교

| 기기 수 | CP-ABE 암호화 시간(초) | 기존 방식 암호화 시간(초) | 효율성 비율(기존/CP-ABE) |
|--------|---------------------|----------------------|-------------------|
| 1 | 0.007442 | 0.000083 | 0.01 |
| 10 | 0.007572 | 0.000257 | 0.03 |
| 50 | 0.007663 | 0.000769 | 0.10 |
| 100 | 0.008598 | 0.001948 | 0.23 |
| 500 | 0.008153 | 0.006732 | 0.83 |
| 1000 | 0.007679 | 0.014313 | 1.86 |
| 2000 | 0.008085 | 0.027607 | 3.41 |
| 5000 | 0.007430 | 0.065542 | 8.82 |

CP-ABE의 암호화 시간은 기기 수와 관계없이 약 0.0076-0.0086초 범위로 거의 일정한 반면, 기존 방식은 기기 수에 비례하여 증가합니다. 특히 1000대 이상에서 CP-ABE의 효율성 우위가 뚜렷해집니다.

### 3.2 부분 키 갱신의 이점

| 속성 수 | 단일 속성 갱신(초) | 전체 키 재발급(초) | 효율성 비율(전체/단일) |
|--------|-----------------|----------------|-------------------|
| 2 | 0.002472 | 0.004647 | 1.88 |
| 4 | 0.002524 | 0.008659 | 3.43 |
| 6 | 0.002670 | 0.012853 | 4.81 |
| 8 | 0.002635 | 0.015150 | 5.75 |
| 10 | 0.002558 | 0.019538 | 7.64 |
| 12 | 0.002484 | 0.022582 | 9.09 |
| 14 | 0.002445 | 0.027217 | 11.13 |

단일 속성 갱신 시간은 속성 수와 관계없이 약 0.0025초로 거의 일정한 반면, 전체 키 재발급은 속성 수에 비례하여 증가합니다. 이로 인해 속성 수가 증가할수록 부분 갱신의 효율성이 더 커집니다.

또한, 실험 범위(최대 14개 속성) 내에서는 부분 갱신과 전체 재발급의 교차점이 발견되지 않았습니다. 이는 속성이 매우 많은 환경에서도 부분 갱신이 항상 유리함을 시사합니다.

### 3.3 접근 제한 효율성

| 기기 수 | CP-ABE 접근 제한(초) | 기존 방식 접근 제한(초) | 효율성 비율(기존/CP-ABE) |
|--------|-------------------|---------------------|-------------------|
| 1 | 0.000045 | 0.000000 | 0.00 |
| 10 | 0.000036 | 0.000011 | 0.31 |
| 50 | 0.000043 | 0.000053 | 1.23 |
| 100 | 0.000039 | 0.000099 | 2.54 |
| 500 | 0.000031 | 0.000431 | 13.90 |
| 1000 | 0.000035 | 0.000857 | 24.49 |

CP-ABE의 접근 제한 시간은 기기 수와 관계없이 약 0.00003-0.00004초로 매우 일정한 반면, 기존 방식은 기기 수가 증가함에 따라 비례해서 증가합니다. 특히 500대 이상에서는 CP-ABE가 기존 방식에 비해 10배 이상 효율적입니다.

### 3.4 대역폭 효율성

| 기기 수 | CP-ABE 대역폭(바이트) | 기존 방식 대역폭(바이트) | 절약률(%) |
|--------|---------------------|----------------------|---------|
| 1 | 360 | 13,785 | 97.4 |
| 10 | 360 | 137,850 | 99.7 |
| 50 | 360 | 689,250 | 99.9 |
| 100 | 360 | 1,378,500 | 100.0 |
| 500 | 360 | 6,892,500 | 100.0 |
| 1000 | 360 | 13,785,000 | 100.0 |

CP-ABE는 기기 수와 무관하게 360바이트로 일정한 반면, 기존 방식은 기기 수에 비례하여 선형적으로 증가합니다. 이로 인해 10대 이상 환경에서도 이미 99.7% 이상의 대역폭을 절약할 수 있으며, 100대 이상에서는 사실상 100%에 가까운 절약률을 보입니다.

## 4. 측정 변동성 및 한계점

일부 실험, 특히 접근 제한 시간 측정에서 발생한 변동성에 대해 분석했습니다:

1. **초정밀 시간 측정의 한계**: 마이크로초 단위의 매우 짧은 시간을 측정할 때 시스템 부하 등 외부 요인에 영향을 받을 수 있습니다.

2. **가비지 컬렉션의 영향**: Python의 자동 메모리 관리는 예측하기 어려운 타이밍으로 발생할 수 있으며, 이로 인해 일부 측정에 변동이 생길 수 있습니다.

3. **JIT 최적화**: Python 인터프리터의 JIT 최적화가 반복 실행에 따라 다르게 적용될 수 있습니다.

이러한 변동성을 최소화하기 위해 각 측정은 여러 번 반복되었으며, 이상치를 제외한 평균값을 사용했습니다. 또한 선형 추세선 분석을 통해 전반적인 패턴을 확인했습니다.

## 5. 결론: CP-ABE의 실제 응용에 대한 영향

실험 결과는 다음과 같은 실제 응용에 대한 중요한 시사점을 제공합니다:

1. **대규모 IoT 플랫폼**: 수천 대의 기기를 관리하는 플랫폼에서 CP-ABE는 암호화 시간과 대역폭 측면에서 현저한 이점을 제공합니다.

2. **제한된 대역폭 환경**: 농촌 지역이나 개발도상국과 같은 제한된 인터넷 환경에서도 효율적인 업데이트 배포가 가능합니다.

3. **구독 기반 서비스 모델**: 자동차, 가전제품 등의 구독 서비스에서 시간 기반 속성을 통해 자연스러운 서비스 관리가 가능합니다.

4. **오프라인 시나리오**: 항상 온라인 상태를 유지할 수 없는 환경에서도 시간 기반 접근 제어를 통해 보안을 유지할 수 있습니다.

교차점이 예상보다 낮은 588대에서 발생한다는 결과는 중소규모 IoT 배포에서도 CP-ABE가 실용적인 이점을 제공할 수 있다는 것을 의미합니다. 따라서 단일 암호화 작업의 복잡성 증가는 확장성, 대역폭 효율성, 관리 용이성의 이점으로 충분히 상쇄됩니다.
