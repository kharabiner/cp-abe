# 5. 실험 방법론 및 성능 평가

본 연구에서는 CP-ABE, Fading Function, 속성 수준 키 갱신 프로토콜로 구성된 IoT 소프트웨어 업데이트 프레임워크의 성능을 평가하기 위해 체계적인 실험을 수행하였다. 제안된 방법의 효율성과 실용성을 입증하기 위해 기존 대칭키 기반 방식과의 비교를 중심으로 실험을 설계하였다.

## 5.1 실험 설계 및 목표

본 실험의 주요 목표는 다음과 같다:

1. **확장성 평가**: 기기 수 증가에 따른 암호화 및 키 관리 효율성 검증
2. **자동 접근 제한 효율성**: Fading Function을 활용한 시간 기반 접근 제한과 기존 취소 메커니즘 비교
3. **부분 키 갱신 효율성**: 전체 키 재발급 대비 속성 수준 갱신의 성능 이점 측정
4. **대역폭 효율성**: 기기 수 증가에 따른 네트워크 통신량 분석
5. **교차점 분석**: 제안 방식이 기존 방식보다 효율적이 되는 기기 수 임계점 도출

## 5.2 실험 환경

### 5.2.1 하드웨어 및 소프트웨어 환경

- **하드웨어**: Docker 컨테이너 환경, 메모리 제한 1GB
- **소프트웨어**: 
  - Python 3.9
  - charm-crypto 라이브러리 (CP-ABE 구현)
  - cryptography 라이브러리 (기존 대칭키 암호화 구현)
  - PBC 라이브러리 0.5.14 (페어링 기반 암호화)

### 5.2.2 속성 구성 체계

실험에서 사용된 속성은 다음과 같이 분류된다:

- **정적 속성**: 변하지 않는 기기 속성
  - 모델(model): 기기의 모델 정보
  - 일련번호(serialNumber): 기기의 고유 식별자
  
- **동적 속성**: 시간에 따라 변하는 속성
  - 구독(subscription): 서비스 구독 상태, Fading Function에 의해 관리됨
  - 보증(warranty): 기기 보증 상태, Fading Function에 의해 관리됨

### 5.2.3 페이딩 함수 설정

동적 속성을 위한 두 가지 페이딩 함수를 구현하였다:

1. **LinearFadingFunction**: 구독 속성에 적용, 일정 시간마다 선형적으로 속성값 변경
   - `subscription_τ = subscription_0 + ⌊(t-t₀)/lifetime⌋`

2. **HardExpiryFadingFunction**: 보증 속성에 적용, 정해진 횟수 갱신 후 영구 만료
   - `warranty_τ = warranty_0 + ⌊(t-t₀)/lifetime⌋` (갱신 횟수 < 최대 갱신 횟수)
   - `warranty_τ = warranty_expired` (갱신 횟수 ≥ 최대 갱신 횟수)

## 5.3 비교 대상 및 구현

### 5.3.1 제안 방식 (CP-ABE 기반)

- **키 생성**: 정적 속성과 동적 속성을 포함한 속성 집합에 기반한 키 생성
- **암호화**: 접근 정책에 따른 단일 암호문 생성 (모든 대상 기기가 동일한 암호문 수신)
- **접근 제한**: 시간 기반 속성 만료를 통한 자동 접근 제한
- **키 갱신**: 만료된 특정 속성만 갱신하는 부분 갱신 프로토콜

### 5.3.2 기존 방식 (대칭키 기반)

- **키 생성**: 각 기기마다 개별 대칭키 생성 및 관리
- **암호화**: 각 기기별 개별 암호화 수행 (기기 수에 비례하는 암호문 생성)
- **접근 제한**: 블랙리스트 관리 및 다른 모든 기기에 키 재발급
- **키 갱신**: 전체 키를 새로 발급하는 방식

## 5.4 측정 지표 및 방법론

### 5.4.1 확장성 측정

- **암호화 시간**: 메시지 암호화에 소요되는 시간(초)
- **키 생성 시간**: 기기당 키 생성에 소요되는 평균 시간(초)
- **기기 수 변화**: 1, 10, 50, 100, 500, 1000, 2000, 3000, 4000, 5000대

### 5.4.2 접근 제한 효율성 측정

- **접근 제한 시간**: 단일 기기 접근 제한에 소요되는 시간(초)
- **총 처리 시간**: 전체 접근 제한 프로세스 완료 시간(초)
- **기기 수 변화**: 1, 10, 50, 100, 500, 1000대

### 5.4.3 키 갱신 효율성 측정

- **갱신 소요 시간**: 키 갱신에 소요되는 시간(초)
- **갱신 유형**: 단일 속성 갱신, 절반 속성 갱신, 전체 속성 갱신, 완전한 키 재발급
- **속성 수 변화**: 2, 4, 6, 8, 10, 12, 14개

### 5.4.4 대역폭 사용량 측정

- **전송 데이터 크기**: 암호화된 메시지 전송에 필요한 데이터 크기(바이트)
- **대역폭 절약률**: CP-ABE와 기존 방식의 상대적 대역폭 사용량 비교(%)
- **기기 수 변화**: 1, 10, 100, 1000대

### 5.4.5 교차점 분석

- **효율성 교차점**: CP-ABE가 기존 방식보다 효율적이 되는 기기 수 분석
- **분석 방법**: 선형 보간 및 교차점 최적화 알고리즘 적용
- **신뢰 구간 측정**: 95% 신뢰 구간 계산을 통한 통계적 유의성 검증

## 5.5 실험 절차

1. **확장성 실험(Scaling Experiment)**: 기기 수 증가에 따른 암호화 및 키 관리 효율성 비교
   - 기기 수: 1, 10, 50, 100, 500, 1000대
   - 측정 항목: 설정 시간, 키 생성 시간, 암호화 시간

2. **접근 제한 실험(Access Limitation Experiment)**: 두 방식의 접근 제한 메커니즘 비교
   - 기기 수: 1, 10, 50, 100, 500, 1000대
   - CP-ABE 측정 항목: 시간 기반 자동 접근 제한(기기 비활성화 처리 시간)
   - 기존 방식 측정 항목: 블랙리스트 추가 시간 및 다른 모든 기기의 키 재발급 시간

3. **구독 갱신 실험(Subscription Renewal Experiment)**: 부분 키 갱신과 전체 키 재발급의 효율성 비교
   - 속성 수: 2, 4, 6, 8, 10, 12, 14개
   - 측정 항목: 단일 속성 갱신, 절반 속성 갱신, 전체 속성 갱신, 완전한 키 재발급 시간

4. **대역폭 사용량 실험(Bandwidth Usage Experiment)**: 기기 수에 따른 네트워크 통신량 분석
   - 기기 수: 1, 10, 100, 1000대
   - 측정 항목: 암호문 크기, 총 전송 데이터양, 대역폭 절약률

5. **교차점 분석(Crossover Analysis)**: CP-ABE와 기존 방식의 효율성 교차점 도출
   - 기기 수: 1~5000대 범위에서 세밀한 측정
   - 분석 방법: 선형 보간 및 교차점 최적화 알고리즘

각 실험은 동일한 시스템 환경에서 여러 번 반복 측정하여 결과의 신뢰성을 높였으며, 이상치 제거 및 선형 회귀 분석을 통해 결과를 검증하였다.

## 5.6 실험 결과 요약

[상세 실험 결과는 'comparative_analysis.md' 문서 참조]
 이상의 기기 환경에서 기존 방식보다 효율적이며, 5000대 환경에서는 약 9배의 성능 우위를 보인다.
실험 결과는 다음과 같은 주요 발견을 제시한다:
대역폭 절약이 가능하다.
1. **확장성**: CP-ABE는 약 588대 이상의 기기 환경에서 기존 방식보다 효율적이며, 5000대 환경에서는 약 9배의 성능 우위를 보인다.
 이상 효율적이다.
2. **대역폭 효율성**: CP-ABE는 기기 수와 무관하게 일정한 대역폭(약 360바이트)을 사용하며, 100대 이상 환경에서 99.9% 이상의 대역폭 절약이 가능하다.

3. **접근 제한 효율성**: 시간 기반 접근 제한 방식은 기기 수와 무관하게 일정한 처리 시간(약 0.00004초)을 보이며, 1000대 환경에서 기존 방식 대비 24배 이상 효율적이다.

4. **키 갱신 효율성**: 속성 수준 갱신은 속성 수가 증가할수록 전체 키 재발급 대비 효율성이 높아지며, 14개 속성 환경에서는 약 11배 이상 효율적이다.실험 결과는 제안된 프레임워크가 기대했던 것보다 더 작은 규모의 IoT 환경(약 588대)에서부터 효율성 이점을 보인다는 점에서 중요한 의미를 가진다.
